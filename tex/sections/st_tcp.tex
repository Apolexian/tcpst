\subsection{Scope Definition}

We have defined the scope of the model to be the main data communication state machine of the protocol, as described in the TCP RFC~\cite{rfc9293} in the state machine overview.
Generally, our model expresses the initial call to open and create a TCB, connection establishment, the main data communication loop, retransmission and connection closing.
We have opted to omit edge cases where no new modelling techniques would be exhibited as these are trivial to add analogously to other cases in the model.
We can express all described cases of opening a connection, namely the basic three way handshake, simultaneous connection synchronization, recovery mechanism from old duplicate SYN, and half-open connections.
We model TCP connection failure given a set R2 threshold and can model communication given that this is set to infinity.
Finally, in terms of connection closing we are again able to express all described cases - the normal close sequence, the simultaneous close sequence and half-closed connections.

Given this definition of a TCP model there are important limitations that must be noted.
Firstly, while the theoretical language presented by Scalas and Yoshida~\cite{SY19} does introduce asynchrony, the tooling does not.
The translation given between MPSTs and the model checking calculus is synchronous.
This omission means that all send and receive actions occur as soon as they are called, which is in contrast to the buffered communication of TCP.
Additionally, synchronous communication does not permit us to model any flush mechanisms, urgent data calls or aggregating calls on the buffer for features such as delayed ACKs.
To reiterate, while the theory of MPST could model all of these on paper, there does not exist the tooling to support the theory.

Secondly, our chosen calculus does not have timeouts as a primitive.
Hence, we have modelled some parts of TCP using implied timeouts.
That is, we assume that a timeout is triggered by a part of the implementation not connected to the session typed state machine.
Once this timeout fires the implementation would pass this as a message to the state machine and a transition will occur.
In the theory of session types there do exist languages with timed features~\cite{BMVY19} and timeouts as a primitive~\cite{BD23}.
Notably, the session typed calculus presented by Bocchi \etal~\cite{BMVY19} has the ability to model both time bound and delayed actions in protocols using binary session types.
In terms of MPST theory, the $MAG\pi$ language~\cite{BD23} defines timeouts, however, it is unclear how timeout branches define timeouts and if each of these timeouts has to be the same.
Additionally, $MAG\pi$ does not consider sending messages after a delay, a feature that would be useful to model TCP.
Further, these languages do not give us the ability to modify timeouts at run-time, which would need to be handled outside the scope of session types.
Similarly to asynchrony, there also does not exist any tooling nor implementations of such languages that could be used for this work.   

\subsection{Session Typed TCP}

With the scope of the model defined, we now discuss how we expressed TCP using session types.
As previously discussed, we opt to use multiparty session types to model the TCP protocol.
Multiparty communication allows us to express TCP closer to its RFC description as opposed to the usual binary session type view of the protocol.
While the binary session type view treats server and client as the only two participants, we explicitly model the communication between the system implementation of TCP and the userspace.
Hence, we have extracted the following roles - the userspace of the server, the server side implementation of TCP, the client side implementation of TCP and the userspace of the client.
The server side of the communication is described by the {\serveruser} and {\serversystem} participants and correspondingly the client side  consists of the {\clientuser} and the {\clientsystem}.
These four roles capture the majority of the state machine described in the RFC, but it is possible to add more roles to explicitly express some TCP features, for example, the protocol's error reporting to the IP layer.
While this would be more accurate, it would also make the model more complex and was deemed out of scope for the initial session typed view of the TCP state machine.
    
\lstinputlisting[language=Ctx, caption={Model of the basic three way handshake and the data loop. Retransmission and connection closing omitted.}, label={snippet:estab_datacomm}]{assets/tcp_snippet_estab_datacomm.ctx}

In the initial OPEN call we assume that one side is the server and the other side is a client.
Hence, we only model the case where the server side requests a passive-open and the client side requests an active-open.
It is also possible to express more fine-grained cases, for example, having an explicit type for each parameter needed for the call and handling each case.
Adding these is trivial if needed and is analogous to adding more match cases and does not change the flow of communication.

After the TCB is created, the connection establishment phase begins.
We model this through the basic three-way handshake.
Connection establishment using the basic three way handshake and the data communication loop from the view point of the \serversystem can be seen in Listing~\ref{snippet:estab_datacomm}.
It is also possible to express the other cases for connection establishment, such as simultaneous open.
Again, this is trivial to add and is omitted for readability.
We opt to explicitly type the connection establishment packets as \textit{SegSynAckSet}, \textit{SegAckSet} and \textit{SegSynSet} instead of just \textit{Seg}.
This allows us to demonstrate the assurances that session types can provide.
By extracting these flag combinations as types, we enforce that during connection establishment we must exhibit the correct pattern.
That is, the server must receive a segment with the SYN flag sent and respond with a segment with the SYN-ACK flags set.
Hence, we do not need to explicitly model the client sending unwanted segments and the server then handling these.
This is because a TCP implementation written using an implementation of session types would not be able to send segments with wrong flags set, assuming a well behaved parser.
So, by being explicit in our types we have more control over the segments being sent which gives us flexibility in how we want to model the protocol.
We can choose to be more general and handle error cases explicitly, or we can be more constrained in what we are allowed to send by having narrower types and disallow such edge-cases from occurring.

Once the handshake is complete we initiate the data communication loop by instantiating a recursive variable on each side.
On the server side, the recursive block accepts a segment from the client and in the case of an accepted sequence number sends that data to its user.
The server then reads from the user and sends a segment with data to the client.

\lstinputlisting[language=Ctx, caption={Closing the connection via user initiated close and an example of simultaneous close.}, label={snippet:close}]{assets/tcp_snippet_connection_close.ctx}

The user can also respond with a CLOSE call, starting the connection closing phase of the protocol.
We model the cases where either server or client initiate the closing handshake by sending a segment with the FIN flag set.
Note that due to the underlying language not having timeouts we do not explicitly model the TIME-AWAIT state.
Instead this is an implied external transition, the server sends the user a CLOSE once the timeout fires outside the session typed state machine.
Listing~\ref{snippet:close} shows a user initiated CLOSE call and a possible simultaneous close from the view point of the server.

\lstinputlisting[language=Ctx, caption={Model of retransmission of a lost segment.}, label={snippet:retrans}]{assets/tcp_snippet_retransmit.ctx}

During data communication it is also possible that we receive an unacceptable segment, in which case retransmission occurs.
In the retransmission cases, the server either successfully receives an acknowledgement for the retransmitted segment or the retry threshold is exceeded and the connection is aborted.
Retransmission initiated by the server can be seen in Listing~\ref{snippet:retrans}.
As previously mentioned, the timeout is implied.
We have not put retransmission everywhere where it is possible as this would make the model unreadable, while not showcasing any other modelling techniques.
It is technically possible for retransmission to occur at any stage of the communication after the very first segment is sent.
Hence, we would need to copy the retransmission block after every communication.
On the client side, data communication, connection closing and retransmission are analogous.
