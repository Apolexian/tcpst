\documentclass{article}

\usepackage[backend=bibtex]{biblatex}
\usepackage{color}
\usepackage[nottoc]{tocbibind}
\usepackage{graphicx}
\usepackage{amsthm}
\usepackage{mathtools,textgreek}
\usepackage{amsmath,amsfonts,amsbsy,amssymb}
\usepackage{geometry}
\usepackage{namespc}
\usepackage{cmll}
\usepackage{float}

\addbibresource{ref.bib}

\graphicspath{ {./assets/} }

\newcommand{\todo}[1]{}
\renewcommand{\todo}[1]{{\color{red} TODO: {#1}}}

\newcommand{\sep}{\;\mid\;}

\title{tcpst todo}
\author{todo}
\date{\today}

\begin{document}

\maketitle

\section{Introduction}

\section{Background}

\subsection{Internet Protocol Standardisation}

\subsection{Session Types}

\todo{binary explanation?}

Multiparty session types (MPST) are a typing discipline that allows us to ensure that a protocol adheres to its session type.
As the name suggests, the theory of MPST focuses on communication between multiple participants.
The classic theory of MPST~\cite{todo} the communication is described from a global view and then projected to the local view of each participant.
\todo{example of classic mpst}.
In this work we use the more general multiparty session type theory (LM) presented by Scalas and Yoshida~\cite{SY19}.
Unlike the classic theory, LM does not base itself on the concepts of global types and duality.
This makes the LM calculus more general - it is able to type more processes.
In addition to this, LM solves the subject reduction flaws that were present in classic MPST theory.

The LM view of multiparty session types is based on the concept of parametrised safety invariants.
This parameter can be adjusted to enforce a number of run-time properties such as deadlock freedom and liveness.

The protocol presented in \todo{the previous example of classic MPST} can be re-written in LM to produce the following typing context.

\todo{same protocol in LM}

If we have a typing context for a protocol that holds with an instantiated safety invariant, then we can say that the run-time process types under this context will hold a similar run-time property.

For example, \todo{explain on example}.

\section{Formalising Internet Protocols Using Session Types}

\todo{
    \begin{itemize}
        \item extracting the typing context from the RFC - discussion on created IR
        \item checking typing context for safety properties
        \item generating code based on typing context that will hold these properties
    \end{itemize}
}

\section{Discussion On Limitations Of The Theory}

\todo{
    \begin{itemize}
        \item We can't express notion of throughput
        \item Generally unclear how we should describe "how much data is being sent" - is this the number of send calls or does the message need to be extended to express this?
        \item There are calculi that do timed and timeouts but these do not have the tooling
        \item Implementation limitations - heterogeneous channels (whats the overhead?), no variadic generics in Rust, will probably encounter other
    \end{itemize}
}

\section{Future Directions}

\todo{
    \begin{itemize}
        \item other properties we may want to parametrise?
        \item model checker reporting - where is property violated?
        \item considering other protocols to exploit other theory of STs? - context free, multiplicities?
    \end{itemize}
}

A new theory of multiparty session types (LM) developed by Scalas and Yoshida~\cite{SY19} removes the concepts of global types and duality.
Instead, LM introduces the concept of behavioural type-level properties.
This change leads to a less restrictive subject reduction that provides a more general theory than classic multiparty session types.

\todo{explain behavioural type-level properties}

\todo{explain how LM is linked to the model checker and introduce the tool}

\todo{explain what benefits model checker has}


\begin{figure}[H]
    \centering
        $
        \begin{array}{rcl}
        \ensuremath{c}
            & \Coloneqq & \ensuremath{s[r] \colon S} \cr
        \ensuremath{S}
            & \Coloneqq & \ensuremath{r \oplus \{l_i(P_i).S_i\}_{i \in I}}
            \sep        \ensuremath{r \with \{l_i(P_i).S_i\}_{i \in I}}
            \sep        \ensuremath{\mu(t).(S)}
            \sep        \ensuremath{t}
            \sep        \ensuremath{end} \cr
        \ensuremath{P}
            & \Coloneqq & \ensuremath{\{TcpPayloadTypes\} \cup \{Pop3PayloadTypes\}}
        \end{array}
        $
    \caption{The syntax of session type contexts used to create the protocol models in \ensuremath{mpstk}.}
    \label{fig:syntax}
\end{figure}

Using the \ensuremath{mpstk} tool we have created models of the POP3 and TCP network protocols.

\todo{explain why TCP is multiparty, check: is this the first ST model that considers TCP to be multiparty?}

The syntax for the session type language that the protocols are written in is presented in Figure~\ref{fig:syntax}.
We do not omit this as the syntax of the language used for \ensuremath{mpstk} differs to that of LM.
Additionally, we only need to consider a simplified subset of the calculus.
Note that \ensuremath{P} can not be an instance of \ensuremath{S}, that is, we do not consider sending sessions across channels.
Although this is standard to the theory of \ensuremath{\pi}-calculus, the presented network protocols would not benefit from such a mechanism.
Hence, the payload types are restricted to the defined TCP and POP3 payload types.

\medskip
\nocite{*}
\printbibliography
\end{document}
