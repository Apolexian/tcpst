\documentclass{article}

\usepackage[backend=bibtex]{biblatex}
\usepackage{color}
\usepackage[nottoc]{tocbibind}
\usepackage{graphicx}
\usepackage{amsthm}
\usepackage{mathtools,textgreek}
\usepackage{amsmath,amsfonts,amsbsy,amssymb}
\usepackage{geometry}
\usepackage{namespc}
\usepackage{cmll}
\usepackage{float}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{hyperref}
\setlength{\parindent}{0em}
\setlength{\parskip}{0.5em}
\hypersetup{%
    colorlinks=true,
    linkcolor=blue,
    bookmarksnumbered,
    citecolor=blue,
    urlcolor=blue,
    bookmarksopen=true}

\addbibresource{ref.bib}

\graphicspath{ {./assets/} }

\newcommand{\todo}[1]{}
\renewcommand{\todo}[1]{{\color{red} TODO: {#1}}}
\renewcommand{\ttfamily}{\usefont{T1}{lmtt}{}{n}}
\newcommand{\type}[1]{\texttt{#1}}

\newcommand{\sep}{\;\mid\;}

\title{tcpst todo}
\author{todo}
\date{\today}

\begin{document}

\maketitle

\section{Introduction}

\section{Background}

\subsection{Internet Protocol Standardisation}

\subsection{Session Types}

Session types are a behavioural typing discipline that were first introduced by Honda~\cite{H93} as a typed formalism for concurrency.
Session types represent a series of actions that each have a type and a direction of data exchange.
Importantly, session types dictate the protocols that the channels must use to communicate.
Consider an example where a client \textbf{C} sends two strings to a server \textbf{S} representing the username and password of the user needed for authentication and expects a boolean, confirming if the user is to be authenticated and then terminates:

\begin{equation*}
    \textbf{C} \; = \; \type{!String.!String.?Boolean.end}
\end{equation*}

This session type describes that \textbf{C}, sends (\type{!}) two strings and then receives (\type{?}) a boolean and then terminates (\type{end}). From the perspective of the server, we have the \textit{dual} session type:

\begin{equation*}
    \textbf{S} \; = \; \type{?String.?String.!Boolean.end}
\end{equation*}

We can see that the server cannot proceed in a way that would be incompatible with the client. This is guaranteed by the notion of \textit{duality}, which means that the sending and receiving sides have consistent typing.
For example, when \textbf{C} sends a string, \textbf{S} expects to receive a string.

We can further understand the importance of duality in a slightly more complex example. Consider now that client \textbf{C} can first choose an authentication method, credentials or token, provide the chosen method and terminate, while the server \textbf{S} will offer two authentication methods and then proceed accordingly depending on the method chosen by the client and terminate:
\begin{align*}
    \begin{split}
        \textbf{C} \; = \; \oplus \;\{\; &\textit{cred}: \type{!String.!String.?Boolean.end}, \\ & \textit{token}: \type {!String.?Boolean.end} \;\}\;
    \end{split}
\end{align*}
\begin{align*}
    \begin{split}
       \textbf{S} \; = \; \& \;\{\; &\textit{cred}: \type{?String.?String.!Boolean.end}, \\ & \textit{token}: \type {?String.!Boolean.end} \;\}\;
    \end{split}
\end{align*}
We now have a session type where the client chooses (\type{$\oplus$}) one of the possible branches that the server offers (\type{\&}), which is represented via the constructs of \textit{selection} and \textit{branching}. Due to the duality concept, the client can't select an authentication method not provided by the server. Hence, we can see how duality ensures \textit{communication safety} by ensuring the compatibility of session types.

Having defined what is meant by session types, it is important to note that the examples provided used \textit{binary session types}; that is, all communication is handled on one channel by two participants. 
To model more complex protocols where two or more participants interact, \textit{multiparty session types}~\cite{HYC16} (MPST) can be used. 
In classic MPST theory, we define a \textit{global type} that describes the communication of all participants and then \textit{project} this into \textit{local session types}, which represent the communication from the viewpoint of each participant.
While the classic MPST theory gives us a global view of communication, it is also overly restrictive in the processes that can be typed due to the consistency restriction.
In this work we use the more general multiparty session type theory (LM) presented by Scalas and Yoshida~\cite{SY19}.
Unlike the classic theory, LM does not base itself on the concepts of global types and duality.
This decoupling from binary session type theory makes the LM calculus more general.

The LM view of multiparty session types is based on the concept of a weak typing context \textit{safety invariant}.
A LM type system is parametric on the safety invariant, that is, by changing the parameter we can control what processes are typed, based on the properties that we want.
The weakest of the invariants is simply safety.
The safe invariant ensures that we have corresponding branches for selections, that recursive unfoldings are safe and that reductions are also safe if the context being reduced is safe.
In order to be typeable under any LM type system a protocol must be at least safe.
The authors present several typing context properties centered around deadlock freedom and liveness.
An example of a protocol in LM looks like the following:

\begin{figure}[H]
    \centering
$
    \begin{array}{rl}
        \textbf{\ensuremath{\Gamma}} \; = \;  & s[a]:\type{b\ensuremath{\with}\textit{l1}(int).c\ensuremath{\oplus}\textit{l3}(int).end}, \cr
        & s[b]:\type{c\ensuremath{\with}\textit{l2}(int).a\ensuremath{\oplus}l1(int)}, \cr
        & s[c]:\type{a\ensuremath{\with}\textit{l3}(int).b\ensuremath{\oplus}l2(int).end}
    \end{array}
$
\end{figure}

In this typing context we have a communication between three participants: \type{a}, \type{b} and \type{c}.
Each participant has a local view of their communication chain, denoted by the \ensuremath{s[role]} syntax.
Similarly, each action is annotated with the participant that the action is directed towards.
We use \ensuremath{l_{i \in I}} to denote labels and the type between brackets denotes the message type.
Unlike the previous binary session type example we use \type{\ensuremath{\oplus}} to denote sending and \type{\ensuremath{\with}} to denote receiving.
This is a purely syntactical choice - sending is a case of selection and receiving is a case of branching where each only have one option.

If we instantiate \type{\ensuremath{\Gamma}} with \type{\ensuremath{\phi}} = \textit{safe}, and derive the needed typing judgement then we will see that this protocol type checks.
Hence, a protocol adhering to this session type can be expected to exhibit a similar property at runtime. 
However, by instantiating \type{\ensuremath{\phi}} = \textit{deadlock-free}, and deriving the typing judgement, we will see that the context is not well typed.
Hence, we can expect that a protocol adhering to this session type will deadlock.
To emphasise, we have made a \textit{static} typing judgement to derive the \textit{runtime} behaviour of a process that abides by \type{\ensuremath{\Gamma}}.
This distinction is crucial as the authors show that the typing context properties are \textit{decidable}, while the runtime process properties are not.
To perform these typing judgements the authors show a further advantage of the flexibility of their theory.
Specifically, its ability to be integrated into various systems.
The authors express \type{\ensuremath{\phi}} as a formula in the \type{\ensuremath{\mu}}-calculus and develop the \ensuremath{mpstk} tool that translates session typed contexts to the \ensuremath{mcrl2}~\cite{BGKLNVWWW19} model checker.
Hence, typing judgements over various safety invariants can be made automatically.

\section{Formalising Internet Protocols Using Session Types}

Based on this, we leverage session type theory to aid network protocol developers during both the draft and implementation stages of protocol design.
We demonstrate how a multiparty session type system can be incorporated and used in a systems programming language to enforce protocol adherence.
Additionally, we provide the translation tooling needed to leverage session types when creating the state machine in the RFC.
Thus, we are able to ensure that an implementation of a protocol follows its corresponding RFC and check the kind of runtime properties the protocol has.
We do this through the following contributions:

\begin{itemize}
    \item An IR to be used in the RFC to extract a session type of the communication state machine of the protocol.
    \item A tool to generate the protocol's session type based on the RFC in the Rust programming language, thus ensuring that the implementation has to follow the described protocol.
    \item A supporting implementation of multiparty session types in the Rust programming language that is generated alongside the protocol's session type.
    \item A tool to generate the \ensuremath{mpstk} typing context either from the session type definition in Rust or directly from the IR. This can be used to check the protocol for desirable properties.
\end{itemize}

We have chosen to focus on TCP as a demonstration of the tooling chain because \todo.

\todo{IR}
\todo{impl and generation - explain how session types help us in Rust (example where something has to follow the session type)}
\todo{explain mpstk, syntax, model checking, etc}

\section{Discussion On Limitations Of The Theory}

\todo{
    \begin{itemize}
        \item We can't express notion of throughput
        \item Generally unclear how we should describe "how much data is being sent" - is this the number of send calls or does the message need to be extended to express this?
        \item There are calculi that do timed and timeouts but these do not have the tooling
        \item Implementation limitations - heterogeneous channels (whats the overhead?), no variadic generics in Rust, will probably encounter other
    \end{itemize}
}

\section{Future Directions}

\todo{
    \begin{itemize}
        \item other properties we may want to parametrise?
        \item model checker reporting - where is property violated?
        \item considering other protocols to exploit other theory of STs? - context free, multiplicities?
    \end{itemize}
}


\begin{figure}[H]
    \centering
        $
        \begin{array}{rcl}
        \ensuremath{c}
            & \Coloneqq & \ensuremath{s[r] \colon S} \cr
        \ensuremath{S}
            & \Coloneqq & \ensuremath{r \oplus \{l_i(P_i).S_i\}_{i \in I}}
            \sep        \ensuremath{r \with \{l_i(P_i).S_i\}_{i \in I}}
            \sep        \ensuremath{\mu(t).(S)}
            \sep        \ensuremath{t}
            \sep        \ensuremath{end} \cr
        \ensuremath{P}
            & \Coloneqq & \ensuremath{\{TcpPayloadTypes\}}
        \end{array}
        $
    \caption{The syntax of session type contexts used to create the protocol models in \ensuremath{mpstk}.}
    \label{fig:syntax}
\end{figure}

\todo{explain why TCP is multiparty, check: is this the first ST model that considers TCP to be multiparty?}

The syntax for the session type language that the protocols are written in is presented in Figure~\ref{fig:syntax}.
We do not omit this as the syntax of the language used for \ensuremath{mpstk} differs to that of LM.
Additionally, we only need to consider a simplified subset of the calculus.
Note that \ensuremath{P} can not be an instance of \ensuremath{S}, that is, we do not consider sending sessions across channels.
Although this is standard to the theory of \ensuremath{\pi}-calculus, the presented network protocols would not benefit from such a mechanism.
Hence, the payload types are restricted to the defined TCP payload types.

\medskip
\nocite{*}
\printbibliography
\end{document}
